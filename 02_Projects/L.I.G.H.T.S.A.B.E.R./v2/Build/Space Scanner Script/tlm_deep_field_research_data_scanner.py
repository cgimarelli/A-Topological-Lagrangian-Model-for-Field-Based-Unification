# -*- coding: utf-8 -*-
"""TLM_Deep_Field_Research_Data_Scanner.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mS3aFTwKgeLQof3bEfPq2gRwQiAk31pi
"""

!pip install astroquery astropy

!pip install ipyaladin

!pip install jupyter

# @title
from ipyaladin import Aladin
aladin = Aladin()
aladin

# @title
import re
from astropy.table import QTable
from astropy.coordinates import SkyCoord
import astropy.units as u

# 1. PASTE YOUR RAW DATA HERE (Keep the format exactly as is)
raw_data = """
17 45 40.05-29 01 10.04
17 45 40.16-29 00 18.73
17 45 41.75-29 00 29.73
17 45 40.40-29 00 37.44
"""

# 2. PARSE THE TEXT
# We use regex to split the RA and Dec because there is no space between them.
# This pattern looks for the +/- sign that divides the two coordinates.
pattern = r"(\d{2} \d{2} \d{2}\.\d{2})([+-]\d{2} \d{2} \d{2}\.\d{2})"
matches = re.findall(pattern, raw_data)

# 3. CREATE ASTROPY OBJECTS (Required by ipyaladin)
if matches:
    # Separate the RA and Dec parts
    ra_list = [m[0] for m in matches]
    dec_list = [m[1] for m in matches]

    # Create a SkyCoord object to handle units automatically
    coords = SkyCoord(ra_list, dec_list, unit=(u.hourangle, u.deg))

    # Create the QTable as specified in the "Displaying a QTable" docs
    table = QTable({
        "ra": coords.ra.deg * u.deg,
        "dec": coords.dec.deg * u.deg,
        "name": [f"Target {i+1}" for i in range(len(coords))]
    })

    # 4. ADD TO ALADIN
    # We map the QTable columns to the ra/dec fields
    aladin.add_table(table, ra_field="ra", dec_field="dec", color="violet", source_size=10)
    print(f"Successfully plotted {len(table)} points.")
else:
    print("No valid coordinates found in the text block.")

"""# Extra Tools

SIMBAD OBJECT QUERY
"""

# @title
import astropy.units as u
from astropy.coordinates import SkyCoord
from astroquery.simbad import Simbad
import warnings
warnings.filterwarnings('ignore')

#####################################################
######     Input Coordinate String below      #######
#####################################################

target_coord = "00h04m45.65071513s +08d19m25.95427219s"

#####################################################

def check_reality(coord_str):
    print(f"--- SIMBAD SEARCH FOR: {coord_str} ---")
    try:
        c = SkyCoord(coord_str, frame='icrs')
        print(f"Decimal: RA {c.ra.deg:.4f} deg, DEC {c.dec.deg:.4f} deg")
        custom_simbad = Simbad()
        custom_simbad.add_votable_fields('main_id', 'id(cat)')
        result_table = custom_simbad.query_region(c, radius=2 * u.arcmin)
        if result_table:
            print(f"\n[REAL OBJECTS FOUND: {len(result_table)}]")
            colnames = result_table.colnames
            id_col = next((name for name in colnames if 'id' in name.lower() or 'main' in name.lower()), colnames[0])
            for i, row in enumerate(result_table[:5]):
                obj_name = row[id_col]
                if hasattr(obj_name, 'decode'):
                    obj_name = obj_name.decode('utf-8')
                print(f"{i+1}. {obj_name}")
        else:
            print("\n[SIMBAD RESULT]: EMPTY VOID (No registered stars within 2 arcmin)")
    except Exception as e:
        print(f"\n[ERROR]: Could not query coordinates. Reason: {e}")
check_reality(target_coord)

"""Save Data as .txt"""

# @title
import sys
from google.colab import files
class Logger(object):
    def __init__(self):
        self.terminal = sys.stdout
        self.log = open("TLM_Deep_Field_Research_Data.txt", "w")
    def write(self, message):
        self.terminal.write(message)
        self.log.write(message)
        self.log.flush()
    def flush(self):
        pass
sys.stdout = Logger()
print("--- SYSTEM REDIRECT ACTIVE: ALL SCANS WILL BE SAVED ---")

"""Save Plots in Folder"""

# @title
import matplotlib.pyplot as plt
import os
if not os.path.exists('plots'): os.makedirs('plots')
def emergency_save():
    count = len(os.listdir('plots')) + 1
    plt.savefig(f'plots/scan_{count:02d}.png')
    plt.close('all')
plt.show = emergency_save
print("--- IMAGE REDIRECT ACTIVE ---")

"""# 2D SPACE MAP

## SECTION A: Singularities
"""

# @title Volumetric 2D Scanner | Target_SECTON_A_1 [TA1]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# A1: Sgr A*
base_ra= 17.761,
base_dec= -29.008,
start_xyz= 26000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_A_2 [TA2]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# A2: M87 Core
base_ra= 12.513,
base_dec= 12.391,
start_xyz= 16000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_A_3 [TA3]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# A3: Cyg X-1
base_ra= 19.972,
base_dec= 35.201,
start_xyz= 7300,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_A_4 [TA4]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# A4: Crab Pulsar
base_ra= 5.576,
base_dec= 22.015,
start_xyz= 6500,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_A_5 [TA5]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# A5: Vela Pulsar
base_ra= 8.589,
base_dec= -45.176,
start_xyz= 930,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_A_6 [TA6]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# A6: Geminga
base_ra= 6.565,
base_dec= 17.77,
start_xyz= 800,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_A_7 [TA7]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# A7: SS 433
base_ra= 19.197,
base_dec= 4.981,
start_xyz= 18000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_A_8 [TA8]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# A8: Cyg X-3
base_ra= 20.401,
base_dec= 33.867,
start_xyz= 7800,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_A_9 [TA9]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# A9: GRO J1655-40
base_ra= 16.901,
base_dec= -39.845,
start_xyz= 11000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_A_10 [TA10]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# A10: GRS 1915+105
base_ra= 19.253,
base_dec= 10.945,
start_xyz= 28000,
search_radius= 10
    )

##########################################################################

"""# SECTION B: Stellar Nurseries"""

# @title Volumetric 2D Scanner | Target_SECTON_B_1 [TB1]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# B1: Orion Nebula
base_ra= 5.588,
base_dec= -5.391,
start_xyz= 1344,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_B_2 [TB2]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# B2: Eagle Nebula
base_ra= 18.312,
base_dec= -13.842,
start_xyz= 7000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_B_3 [TB3]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# B3: Carina Nebula
base_ra= 10.749,
base_dec= -59.684,
start_xyz= 8500,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_B_4 [TB4]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# B4: Lagoon Nebula
base_ra= 18.041,
base_dec= -24.372,
start_xyz= 4100,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_B_5 [TB5]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# B5: Trifid Nebula
base_ra= 18.038,
base_dec= -23.031,
start_xyz= 5200,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_B_6 [TB6]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# B6: Rho Ophiuchi
base_ra= 16.468,
base_dec= -24.541,
start_xyz= 460,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_B_7 [TB7]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# B7: Tarantula (LMC)
base_ra= 5.644,
base_dec= -69.101,
start_xyz= 160000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_B_8 [TB8]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# B8: N. America Neb
base_ra= 20.985,
base_dec= 44.318,
start_xyz= 2200,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_B_9 [TB9]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# B9: Rosette Nebula
base_ra= 6.538,
base_dec= 4.998,
start_xyz= 5200,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_B_10 [TB10]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# B10: Omega Nebula
base_ra= 18.347,
base_dec= -16.182,
start_xyz= 5500,
search_radius= 10
    )

##########################################################################

"""# SECTION C: Main Sequence"""

# @title Volumetric 2D Scanner | Target_SECTON_C_1 [TC1]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
base_ra= 6.752,
base_dec= -16.716,
start_xyz= 500,
search_radius= 4.0
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_C_2 [TC2]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# C2: Vega
base_ra= 18.615,
base_dec= 38.784,
start_xyz= 500,
search_radius= 4.0
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_C_3 [TC3]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# C3: Polaris
base_ra= 2.531,
base_dec= 89.264,
start_xyz= 500,
search_radius= 4.0
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_C_4 [TC4]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# C4: Pleiades
base_ra= 3.79,
base_dec= 24.117,
start_xyz= 500,
search_radius= 4.0
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_C_5 [TC5]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# C5: Arcturus
base_ra= 14.261,
base_dec= 19.182,
start_xyz= 500,
search_radius= 4.0
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_C_6 [TC6]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# C6: Procyon
base_ra= 7.655,
base_dec= 5.226,
start_xyz= 500,
search_radius= 4.0
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_C_7 [TC7]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# C7: Alpha Cen
base_ra= 14.66,
base_dec= -60.834,
start_xyz= 500,
search_radius= 4.0
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_C_8 [TC8]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# C8: Antares
base_ra= 16.49,
base_dec= -26.432,
start_xyz= 550,
search_radius= 6.0
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_C_9 [TC9]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# C9: Rigel
base_ra= 5.242,
base_dec= -8.201,
start_xyz= 860,
search_radius= 6.0
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_C_10 [TC10]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# C10: Altair
base_ra= 19.846,
base_dec= 8.868,
start_xyz= 500,
search_radius= 4.0
    )

##########################################################################

"""# SECTION D: Dark Sector"""

# @title Volumetric 2D Scanner | Target_SECTON_D_1 [TD1]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# D1: Abell 2218
base_ra= 16.592,
base_dec= 66.216,
start_xyz= 50000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_D_2 [TD2]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# D2: Bullet Cluster
base_ra= 6.585,
base_dec= -55.946,
start_xyz= 50000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_D_3 [TD3]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# D3: Abell 1689
base_ra= 13.193,
base_dec= -1.334,
start_xyz= 50000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_D_4 [TD4]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# D4: Abell 370
base_ra= 2.664,
base_dec= -1.571,
start_xyz= 50000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_D_5 [TD5]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# D5: Coma Cluster
base_ra= 12.997,
base_dec= 27.981,
start_xyz= 50000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_D_6 [TD6]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# D6: Perseus Cluster
base_ra= 3.329,
base_dec= 41.512,
start_xyz= 50000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_D_7 [TD7]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# D7: Abell 1835
base_ra= 14.017,
base_dec= 2.871,
start_xyz= 50000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_D_8 [TD8]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# D8: Abell 2744
base_ra= 0.239,
base_dec= -30.401,
start_xyz= 50000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_D_9 [TD9]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# D9: CL 0024+17
base_ra= 0.443,
base_dec= 17.151,
start_xyz= 50000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_D_10 [TD10]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# D10: RX J1347
base_ra= 13.791,
base_dec= -11.753,
start_xyz= 50000,
search_radius= 10
    )

##########################################################################

"""# SECTION E: COSMIC VOIDS"""

# @title Volumetric 2D Scanner | Target_SECTON_E_1 [TE1]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# E1: Botes Void
base_ra= 14.83,
base_dec= 46.00,
start_xyz= 50000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_E_2 [TE2]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# E2: Eridanus Void
base_ra= 3.25,
base_dec= -19.58,
start_xyz= 50000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_E_3 [TE3]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# E3: Local Void
base_ra= 18.63,
base_dec= 18.84,
start_xyz= 20000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_E_4 [TE4]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# E4: Giant Void
base_ra= 13.0,
base_dec= 35.0,
start_xyz= 50000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_E_5 [TE5]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
base_ra= 15.51,
base_dec= 15.11,
start_xyz= 50000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_E_6 [TE6]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
base_ra= 4.51,
base_dec= 30.11,
start_xyz= 50000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_E_7 [TE7]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# E7: Sculptor Void
base_ra= 23.81,
base_dec= -24.65,
start_xyz= 50000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_E_8 [TE8]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# E8: Pegasus Void
base_ra= 22.11,
base_dec= 15.11,
start_xyz= 50000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_E_9 [TE9]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# E9: Ophiuchus Void
base_ra= 17.0,
base_dec= -25.0,
start_xyz= 50000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_E_10 [TE10]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
base_ra= 20.9,
base_dec= -30.0,
start_xyz= 50000,
search_radius= 10
    )

##########################################################################

"""# SECTION F: FERMI BUBBLES"""

# @title Volumetric 2D Scanner | Target_SECTON_F_1 [TF1]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# F1: Galactic Center
base_ra= 17.761,
base_dec= -29.008,
start_xyz= 26000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_F_2 [TF2]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# F2: North Lobe Low (b=+15)
base_ra= 17.5,
base_dec= -15.0,
start_xyz= 28000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_F_3 [TF3]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# F3: North Lobe Mid (b=+30)
base_ra= 17.2,
base_dec= -1.0,
start_xyz= 30000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_F_4 [TF4]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# F4: North Lobe High (b=+45)
base_ra= 16.7,
base_dec= 14.0,
start_xyz= 32000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_F_5 [TF5]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# F5: North Lobe Top (b=+55)
base_ra= 16.4,
base_dec= 22.0,
start_xyz= 27000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_F_6 [TF6]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# F6: South Lobe Low (b=-15)
base_ra= 18.1,
base_dec= -43.0,
start_xyz= 35000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_F_7 [TF7]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# F7: South Lobe Mid (b=-30)
base_ra= 18.7,
base_dec= -57.0,
start_xyz= 31000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_F_8 [TF8]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# F8: South Lobe High (b=-45)
base_ra= 19.5,
base_dec= -68.0,
start_xyz= 29000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_F_9 [TF9]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# F9: South Lobe Bot (b=-55)
base_ra= 20.5,
base_dec= -73.0,
start_xyz= 40000,
search_radius= 10
    )

##########################################################################

# @title Volumetric 2D Scanner | Target_SECTON_F_10 [TF10]
import numpy as np
import matplotlib.pyplot as plt
import hashlib
import warnings
import logging

try:
    from astroquery.simbad import Simbad
    from astropy.coordinates import SkyCoord
    import astropy.units as u
    from astroquery.exceptions import NoResultsWarning

    warnings.filterwarnings("ignore")
    logging.getLogger('astroquery').setLevel(logging.ERROR)

    Simbad.add_votable_fields('main_id', 'otype', 'ra(d)', 'dec(d)')
    Simbad.TIMEOUT = 120
    SIMBAD_AVAILABLE = True
except ImportError:
    SIMBAD_AVAILABLE = False
    print("!! WARNING: 'astroquery' or 'astropy' not installed. Simbad lookups will be disabled.")

PLANCK_LENGTH = 1.616255e-35
HUBBLE_CONST = 2.27e-18
C_LIGHT = 2.99792458e8
LAMBDA_COSMO = 1.7e-52
N_DIRAC = ( (C_LIGHT / (HUBBLE_CONST * PLANCK_LENGTH)) )**(2/3)
BETA_STIFFNESS = LAMBDA_COSMO * N_DIRAC
GAMMA_MODULUS = PLANCK_LENGTH**2

def perform_simbad_lookup(coord_str):
    if SIMBAD_AVAILABLE == False: return "SIMBAD N/A", "N/A", None, None
    try:
        c = SkyCoord(coord_str, frame='icrs')
        result_table = Simbad.query_region(c, radius=5 * u.arcmin)
        if result_table:
            raw_cols = result_table.colnames
            def find_col(possible_names):
                for name in possible_names:
                    for raw in raw_cols:
                        if name.lower() in raw.lower(): return raw
                return None
            id_col = find_col(['main_id', 'id', 'name']) or raw_cols[0]
            ra_col = find_col(['ra(d)', 'ra_d', 'ra'])
            dec_col = find_col(['dec(d)', 'dec_d', 'dec'])
            otype_col = find_col(['otype', 'type'])
            ras = np.array(result_table[ra_col]).astype(float)
            decs = np.array(result_table[dec_col]).astype(float)
            res_coords = SkyCoord(ra=ras*u.deg, dec=decs*u.deg, frame='icrs')
            seps = c.separation(res_coords)
            idx = np.argmin(seps)
            row = result_table[idx]
            name = str(row[id_col])
            obj_type = str(row[otype_col]) if otype_col else "Object"
            return f"MATCH: {name} ({obj_type})", f"{seps[idx].arcsecond:.2f}\"", ras[idx], decs[idx]
        return "NO MATCH", "N/A", None, None
    except Exception:
        return "SIMBAD FAIL", "N/A", None, None

class VolumetricScanner:
    def __init__(self, N_ensemble=25, shear_modulus=1.25):
        self.N = N_ensemble
        self.shear = shear_modulus
        self.BARYONIC_FLOOR = 12.0

    def hash_coordinate(self, x, y, z):
        coord_str = f"{x:.4f}|{y:.4f}|{z:.4f}"
        hash_obj = hashlib.md5(coord_str.encode())
        return int(hash_obj.hexdigest(), 16) % 4294967295

    def get_vacuum_state(self, x, y, z):
        seed_val = self.hash_coordinate(x, y, z)
        np.random.seed(seed_val)
        limit = (np.pi / 4.0) * self.shear
        phases = np.random.uniform(-limit, limit, self.N)
        complex_mean = np.mean(np.exp(1j * phases))
        sync_val = np.abs(complex_mean)
        hard_sync = np.clip(sync_val / (1.0 - (sync_val * 0.5)), sync_val, 0.9999)
        return hard_sync, complex_mean

    def get_topological_invariants(self, x, y, z):
        eps = 0.02
        _, z0 = self.get_vacuum_state(x, y, z)
        theta0 = np.angle(z0)
        _, zx = self.get_vacuum_state(x + eps, y, z)
        _, zy = self.get_vacuum_state(x, y + eps, z)
        _, zz = self.get_vacuum_state(x, y, z + eps)

        I_vec = np.array([(np.angle(zx) - theta0) / eps,
                          (np.angle(zy) - theta0) / eps,
                          (np.angle(zz) - theta0) / eps])
        shear_vel = np.linalg.norm(I_vec)

        _, zyx = self.get_vacuum_state(x + eps, y + eps, z)
        vorticity_z = ((np.angle(zyx) - np.angle(zx)) / eps) - ((np.angle(zyx) - np.angle(zy)) / eps)
        helicity = shear_vel * abs(vorticity_z)
        return shear_vel, helicity

    def analyze_topology(self, hard_sync, complex_mean):
        if hard_sync <= 0.0: return 0, 0, 0
        phase_angle = np.angle(complex_mean)
        normalized_phase = (phase_angle + np.pi) / (2 * np.pi)
        floor = normalized_phase * self.N
        floor_delta = abs(floor - self.BARYONIC_FLOOR) + 0.01
        pull = (hard_sync**2) / np.sqrt(floor_delta)
        m_raw = pull / (self.N * (hard_sync**2))
        m = m_raw * 5.5
        d_confinement = (GAMMA_MODULUS / BETA_STIFFNESS)**0.25 * 1e15
        rms_radius_fm = 0.775 * (d_confinement / 2.0)
        return pull, m, rms_radius_fm

    def classify_matter(self, m, hard_sync, kinetic, helicity, pull):
        if pull < 1.0 and hard_sync > 0.99: return "Minkowskian Baseline"
        if pull > 2.0 and m < 0.15: return "Non-Local Metric Deformation"
        if helicity > 50.0:
            if m > 1.5: return "Spacetime Curvature Limit (Black Hole)"
            elif kinetic > 20.0: return "Localized Torsional Inflection"
        if hard_sync > 0.95:
            if 0.28 <= m < 0.32: return "Solenoidal Metric Schema (Iron)"
            if 0.32 <= m < 0.36: return "Helical Metric Schema"
            if 0.36 <= m < 0.45: return "Trefoil Metric Schema"
            if 0.80 <= m < 1.20: return "Baryonic Metric Substrate"
        if 0.15 <= m < 0.28: return "Gasious Substrate Schema"
        return "Metric Spacetime Anomaly"

    def cartesian_to_astronomical(self, x, y, z):
        r = np.sqrt(x**2 + y**2 + z**2) or 1e-9
        dec_rad = np.arcsin(z / r)
        ra_rad = np.arctan2(y, x)
        ra_deg = (np.degrees(ra_rad) + 360) % 360
        dec_deg = np.degrees(dec_rad)
        alpha_inv = 137.035999084
        drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
        ra_deg = (ra_deg + drag_shift) % 360
        ra_h = int(ra_deg / 15.0)
        ra_m = int((ra_deg / 15.0 - ra_h) * 60)
        ra_s = ((ra_deg / 15.0 - ra_h) * 60 - ra_m) * 60
        sign = "+" if dec_deg >= 0 else "-"
        abs_dec = abs(dec_deg)
        dec_d = int(abs_dec)
        dec_m = int((abs_dec - dec_d) * 60)
        dec_s = ((abs_dec - dec_d) * 60 - dec_m) * 60
        return f"{ra_h:02d}h{ra_m:02d}m{ra_s:05.2f}s {sign}{dec_d:02d}d{dec_m:02d}m{dec_s:05.2f}s"

    def scan_sector(self, center_coord, radius):
        volume = (4/3) * np.pi * (radius**3)
        num_points = int(volume * 0.1)
        if num_points > 8000: num_points = 8000

        print(f"Scanning Volume... Sampling {num_points} points.")
        rng = np.random.default_rng(int(abs(sum(center_coord) * radius)) % 4294967295)

        phi = rng.uniform(0, 2*np.pi, num_points)
        costheta = rng.uniform(-1, 1, num_points)
        u_rand = rng.uniform(0, 1, num_points)
        theta = np.arccos(costheta)
        r_dist = radius * np.cbrt(u_rand)

        xs = r_dist * np.sin(theta) * np.cos(phi)
        ys = r_dist * np.sin(theta) * np.sin(phi)
        zs = r_dist * np.cos(theta)

        xs = center_coord[0] + xs
        ys = center_coord[1] + ys
        zs = center_coord[2] + zs

        plot_data = []
        for i in range(num_points):
            k, z_complex = self.get_vacuum_state(xs[i], ys[i], zs[i])
            kin, hel = self.get_topological_invariants(xs[i], ys[i], zs[i])
            if k > 0.6 or hel > 4.0:
                pull, m, rad = self.analyze_topology(k, z_complex)
                identity = self.classify_matter(m, k, kin, hel, pull)
                coord_str = self.cartesian_to_astronomical(xs[i], ys[i], zs[i])

                # Re-calculate simple floats for the 2D plot
                r = np.sqrt(xs[i]**2 + ys[i]**2 + zs[i]**2) or 1e-9
                dec_rad = np.arcsin(zs[i] / r)
                ra_rad = np.arctan2(ys[i], xs[i])
                ra_deg = (np.degrees(ra_rad) + 360) % 360
                alpha_inv = 137.035999084
                drag_shift = (1.5 / self.N) * (1.0 / alpha_inv)
                ra_deg = (ra_deg + drag_shift) % 360
                ra_h = ra_deg / 15.0
                dec_d = np.degrees(dec_rad)

                plot_data.append({
                    'ra': ra_h,
                    'dec': dec_d,
                    'mode': m,
                    'radius': rad,
                    'matter_id': identity,
                    'helicity': hel,
                    'coord_str': coord_str
                })
        return plot_data

# --- PLOTTING FUNCTION ---
def plot_spectral_map(results):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor('#0b0e14')
    ax.set_facecolor('#0b0e14')

    ra = [r['ra'] for r in results]
    dec = [r['dec'] for r in results]
    modes = [r['mode'] for r in results]
    radii = [r['radius'] * 60 for r in results]

    sc = ax.scatter(ra, dec, s=radii, c=modes, cmap='nipy_spectral', alpha=0.8, edgecolors='none')

    iron_ra = [r['ra'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    iron_dec = [r['dec'] for r in results if "Solenoidal" in r['matter_id'] or "Iron" in r['matter_id']]
    if iron_ra:
        ax.scatter(iron_ra, iron_dec, s=250, facecolors='none', edgecolors='lime', linewidth=2, label='Stable Cores (Iron)')

    bh_ra = [r['ra'] for r in results if "Black Hole" in r['matter_id']]
    bh_dec = [r['dec'] for r in results if "Black Hole" in r['matter_id']]
    if bh_ra:
        ax.scatter(bh_ra, bh_dec, s=150, marker='x', color='red', linewidth=3, label='Metric Fractures (BH)')

    cbar = plt.colorbar(sc, ax=ax)
    cbar.set_label('Topological Mode (m) - [Spectral Stress]')
    ax.set_title("VOLUMETRIC TOPOLOGY MAP: Projected Density", loc='left', color='cyan', fontsize=16, fontweight='bold')
    ax.set_xlabel("Right Ascension (Hours)", fontsize=12, color='white')
    ax.set_ylabel("Declination (Degrees)", fontsize=12, color='white')
    ax.invert_xaxis()
    ax.legend(loc='upper right', frameon=True, facecolor='#1a1a1a', edgecolor='cyan')
    ax.grid(True, color='#2a2a35', alpha=0.3)
    plt.tight_layout()
    plt.show()

# --- EXECUTION WRAPPER ---
def execute_volumetric_scan(base_ra, base_dec, start_xyz, search_radius):
    print(f"--- INITIATING VOLUMETRIC METRIC SCAN ---")
    print(f"Target: RA {base_ra}, DEC {base_dec}")
    print(f"Depth: {start_xyz} XYZ | Radius: {search_radius}")

    # Convert RA/Dec to Cartesian Center for the Scanner
    ra_rad = np.radians(base_ra * 15)
    dec_rad = np.radians(base_dec)
    x_c = start_xyz * np.cos(dec_rad) * np.cos(ra_rad)
    y_c = start_xyz * np.cos(dec_rad) * np.sin(ra_rad)
    z_c = start_xyz * np.sin(dec_rad)

    # Run Scan
    scanner = VolumetricScanner()
    scan_results = scanner.scan_sector((x_c, y_c, z_c), search_radius)

    if not scan_results:
        print("No structure detected in this volume.")
    else:
        print(f"Structure Detected: {len(scan_results)} metric nodes.")

        # PLOT
        plot_spectral_map(scan_results)

        # AUDIT
        print("\n" + "="*140)
        print("FULL SIMBAD REALITY CHECK - ALL NODES")
        print("="*140)
        print(f"{'PREDICTED COORDINATES':<32} | {'MODE (m)':<8} | {'HELICITY':<8} | {'PREDICTED IDENTITY':<35} | {'OFFSET':<10} | {'REALITY CHECK'}")
        print("-" * 140)

        for node in scan_results:
            coord = node['coord_str']
            mode = node['mode']
            hel = node['helicity']
            ident = node['matter_id']
            sim_res, off_arc, real_ra, real_dec = perform_simbad_lookup(coord)
            print(f"{coord:<32} | {mode:<8.4f} | {hel:<8.4f} | {ident:<35} | {off_arc:<10} | {sim_res}")

##########################################################################
###### Adjust base_ra, base_dec, start_xyz, and search_radius below ######
##########################################################################

if __name__ == "__main__":
    execute_volumetric_scan(
# F10: East Edge (l=10)
base_ra= 18.5,
base_dec= -29.0,
start_xyz= 26500,
search_radius= 10
    )

##########################################################################

!zip -r my_scans.zip plots/