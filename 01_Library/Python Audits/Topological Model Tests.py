# -*- coding: utf-8 -*-
"""Topological Model Tests

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1otToRo-gSznC4QB1w_Ie-ZO45ZWK-FKa
"""

import unittest
import numpy as np
import sympy as sp
from sympy.physics.vector import ReferenceFrame

class TestTopologicalLagrangianModel(unittest.TestCase):
    """
    Test suite for 'A Topological Lagrangian Model for Field-Based Unification'.
    Verifies symbolic derivations and numerical properties of the field definitions.
    """

    def setUp(self):
        # Constants for numerical tests
        self.hbar = 1.054e-34
        self.lambda_val = 1.0
        self.beta = 1e-12
        self.alpha = 0.5

    def test_theorem_3_3_intention_alignment_symbolic(self):
        """
        Symbolic verification of Theorem 3.3: Intention-Awareness Alignment.
        We differentiate L_int with respect to I_mu and check if setting it to 0
        yields the equation I^mu = (alpha/2beta) * nabla^mu psi.
        """
        print("\n--- Testing Theorem 3.3 (Symbolic) ---")

        # Define symbols
        alpha, beta = sp.symbols('alpha beta', real=True, positive=True)
        # We treat I and nabla_psi as vectors for this derivation
        I = sp.MatrixSymbol('I', 4, 1) # Contravariant I^mu
        nabla_psi = sp.MatrixSymbol('nabla_psi', 4, 1) # Covariant derivative of psi

        # Metric g (simplified to flat Minkowski for local derivation validity)
        # Note: In curved space, the algebraic derivation for a non-derivative coupling holds the same.
        # We will just work with the scalar products.

        # Let's represent the scalar products abstractly
        # L_int = -alpha * I_mu * nabla^mu psi + beta * I_mu * I^mu
        # In a local frame, we can treat components independently.

        I_mu = sp.symbols('I_mu')
        grad_psi_mu = sp.symbols('grad_psi_mu')

        # Lagrangian Density (component-wise contribution)
        # L = -alpha * (I_mu * grad_psi_mu) + beta * (I_mu * I_mu)
        # Note: We assume metric signature allows us to sum these, verifying the stationary point algebra.
        L_int = -alpha * I_mu * grad_psi_mu + beta * I_mu**2

        # Differentiate w.r.t I_mu
        dL_dI = sp.diff(L_int, I_mu)
        print(f"dL/dI_mu = {dL_dI}")

        # Solve for I_mu when derivative is zero
        solution = sp.solve(dL_dI, I_mu)[0]
        print(f"Stationary point I_mu = {solution}")

        # Expected from paper Eq (17): I^mu = (alpha/2beta) * nabla^mu psi
        # Note: Our simple L above used covariant * covariant for the first term implicitly
        # strictly it's I_u * grad^u. If we treat I_mu as the variable, the form matches.
        expected = (alpha / (2 * beta)) * grad_psi_mu

        self.assertEqual(solution, expected, "Theorem 3.3 Derivation failed: Symbolic result does not match Eq(17)")
        print("Theorem 3.3 Verified: Intention vector aligns with awareness gradient.")

    def test_collapse_potential_minima(self):
        """
        Numerical verification of Theorem 3.2: Phase-Loop Criterion.
        Checks that V(psi) = lambda[1 - cos(delta_theta)] has minima at 2*pi*n.
        """
        print("\n--- Testing Theorem 3.2 (Numerical) ---")

        def potential(delta_theta, lambda_c=1.0):
            return lambda_c * (1 - np.cos(delta_theta))

        # Test range of angles
        thetas = np.linspace(-4*np.pi, 4*np.pi, 100)
        V_values = potential(thetas)

        # Check specific points: 0, 2pi, -2pi should be zero (ground states)
        critical_points = [0, 2*np.pi, -2*np.pi]
        epsilon = 1e-10

        for theta in critical_points:
            val = potential(theta)
            self.assertLess(val, epsilon, f"Potential at {theta} should be ~0 (Vacuum state)")
            print(f"Checked Vacuum State at theta={theta:.2f}: V={val}")

        # Check a non-integer multiple of 2pi (e.g., pi)
        val_pi = potential(np.pi)
        self.assertAlmostEqual(val_pi, 2.0 * self.lambda_val, places=5,
                             msg="Potential at pi should be maximal (2*lambda)")
        print(f"Checked Excited State at theta=pi: V={val_pi}")

    def test_lemma_a1_variation(self):
        """
        Symbolic verification of Lemma A.1.
        Verifies the functional derivative of the cosine potential leads to the sine term.
        """
        print("\n--- Testing Lemma A.1 (Symbolic) ---")

        theta = sp.symbols('theta')
        lambda_sym = sp.symbols('lambda')

        # V = lambda * (1 - cos(theta))
        # Note: In the paper, theta is Delta_theta.
        V = lambda_sym * (1 - sp.cos(theta))

        # Derivative w.r.t theta
        dV_dtheta = sp.diff(V, theta)

        print(f"V = {V}")
        print(f"dV/dtheta = {dV_dtheta}")

        expected = lambda_sym * sp.sin(theta)
        self.assertEqual(dV_dtheta, expected, "Lemma A.1 failed: Derivative of potential is not lambda*sin(theta)")
        print("Lemma A.1 Verified: Restoring force is sinusoidal.")

    def test_metric_perturbation_symmetry_eq11(self):
        """
        Numerical verification of Equation 11: Metric Perturbation Tensor Xi_mu_nu.
        Ensures the construction yields a symmetric tensor, which is required for it
        to be added to the metric g_mu_nu.
        """
        print("\n--- Testing Metric Perturbation Symmetry (Eq 11) ---")

        # Mock 4-vectors
        # Gradient of psi (complex) -> split into real/imag for simulation,
        # but Eq 11 uses d(psi*)d(psi).
        # Let's assume psi = A * e^(i*theta), so d_mu psi is complex.

        # Random complex gradients for d_mu_psi
        d_psi = np.random.rand(4) + 1j * np.random.rand(4)
        d_psi_star = np.conjugate(d_psi)

        # Random real intention vector I_mu
        I = np.random.rand(4)

        gamma = 0.1
        sigma_I = 1.5

        # Construct Xi_mu_nu
        # Eq 11: Xi_uv = d_(u psi* d_v) psi + (gamma/sigma^2) * I_u * I_v
        # Note: The paper writes d_(u psi* d_v) psi.
        # Standard notation d_(u...v) usually implies symmetrization,
        # but d_u psi* * d_v psi is already Hermitian symmetric if we look at the whole form?
        # Actually, d_u psi* d_v psi is NOT symmetric in u,v unless d_u psi is proportional to d_v psi.
        # However, the paper notation likely implies symmetrization or the term itself is:
        # Eq 11 text: "d_(u psi* d_v) psi"
        # The parentheses () around indices usually denote symmetrization: T_(ab) = 1/2(T_ab + T_ba).

        Xi = np.zeros((4,4), dtype=complex)

        term2_prefactor = gamma / (sigma_I**2)

        for mu in range(4):
            for nu in range(4):
                # Calculate the raw term d_mu psi* * d_nu psi
                raw_term = d_psi_star[mu] * d_psi[nu]

                # Apply symmetrization logic implied by d_(u ... v)
                # If the paper means partial_(mu psi*) * partial_nu(psi), this isn't symmetric.
                # If the paper implies symmetrization of the indices:
                # Term 1 = 0.5 * (d_mu psi* d_nu psi + d_nu psi* d_mu psi)

                # Let's calculate the term assuming the symmetrization brackets in Eq 11 apply to the indices
                term1 = 0.5 * (d_psi_star[mu] * d_psi[nu] + d_psi_star[nu] * d_psi[mu])

                term2 = term2_prefactor * I[mu] * I[nu]

                Xi[mu, nu] = term1 + term2

        # Check symmetry: Xi_mu_nu == Xi_nu_mu
        is_symmetric = np.allclose(Xi, Xi.T)
        self.assertTrue(is_symmetric, "Metric Perturbation Xi_mu_nu is not symmetric!")
        print(f"Metric Perturbation Symmetry Verified: {is_symmetric}")

        # Additional Check: Real-valuedness
        # The metric must be real. The term d_mu psi* d_nu psi is not generally real.
        # However, the symmetrized version (d* d + d* d) might still be complex?
        # (a-ib)(c+id) + (c-id)(a+ib) = (ac + bd + i(ad-bc)) + (ca + db + i(cb-da))
        # = 2(ac+bd). The imaginary parts cancel!
        # Let's check if our calculated Xi is real.
        max_imag = np.max(np.abs(Xi.imag))
        self.assertLess(max_imag, 1e-10, "Metric Perturbation must be real-valued")
        print("Metric Perturbation Real-Valuedness Verified")

if __name__ == '__main__':
    unittest.main()

import unittest
import numpy as np
import sympy as sp
from sympy.physics.vector import ReferenceFrame

class TestTopologicalLagrangianModel(unittest.TestCase):
    """
    Test suite for 'A Topological Lagrangian Model for Field-Based Unification'.
    Verifies symbolic derivations and numerical properties of the field definitions.
    """

    def setUp(self):
        # Constants for numerical tests
        self.hbar = 1.054e-34
        self.lambda_val = 1.0
        self.beta = 1e-12
        self.alpha = 0.5

    def test_theorem_3_3_intention_alignment_symbolic(self):
        """
        Symbolic verification of Theorem 3.3: Intention-Awareness Alignment.
        We differentiate L_int with respect to I_mu and check if setting it to 0
        yields the equation I^mu = (alpha/2beta) * nabla^mu psi.
        """
        print("\n--- Testing Theorem 3.3 (Symbolic) ---")

        # Define symbols
        alpha, beta = sp.symbols('alpha beta', real=True, positive=True)
        # We treat I and nabla_psi as vectors for this derivation
        I = sp.MatrixSymbol('I', 4, 1) # Contravariant I^mu
        nabla_psi = sp.MatrixSymbol('nabla_psi', 4, 1) # Covariant derivative of psi

        # Metric g (simplified to flat Minkowski for local derivation validity)
        # Note: In curved space, the algebraic derivation for a non-derivative coupling holds the same.
        # We will just work with the scalar products.

        # Let's represent the scalar products abstractly
        # L_int = -alpha * I_mu * nabla^mu psi + beta * I_mu * I^mu
        # In a local frame, we can treat components independently.

        I_mu = sp.symbols('I_mu')
        grad_psi_mu = sp.symbols('grad_psi_mu')

        # Lagrangian Density (component-wise contribution)
        # L = -alpha * (I_mu * grad_psi_mu) + beta * (I_mu * I_mu)
        # Note: We assume metric signature allows us to sum these, verifying the stationary point algebra.
        L_int = -alpha * I_mu * grad_psi_mu + beta * I_mu**2

        # Differentiate w.r.t I_mu
        dL_dI = sp.diff(L_int, I_mu)
        print(f"dL/dI_mu = {dL_dI}")

        # Solve for I_mu when derivative is zero
        solution = sp.solve(dL_dI, I_mu)[0]
        print(f"Stationary point I_mu = {solution}")

        # Expected from paper Eq (17): I^mu = (alpha/2beta) * nabla^mu psi
        # Note: Our simple L above used covariant * covariant for the first term implicitly
        # strictly it's I_u * grad^u. If we treat I_mu as the variable, the form matches.
        expected = (alpha / (2 * beta)) * grad_psi_mu

        self.assertEqual(solution, expected, "Theorem 3.3 Derivation failed: Symbolic result does not match Eq(17)")
        print("Theorem 3.3 Verified: Intention vector aligns with awareness gradient.")

    def test_collapse_potential_minima(self):
        """
        Numerical verification of Theorem 3.2: Phase-Loop Criterion.
        Checks that V(psi) = lambda[1 - cos(delta_theta)] has minima at 2*pi*n.
        """
        print("\n--- Testing Theorem 3.2 (Numerical) ---")

        def potential(delta_theta, lambda_c=1.0):
            return lambda_c * (1 - np.cos(delta_theta))

        # Test range of angles
        thetas = np.linspace(-4*np.pi, 4*np.pi, 100)
        V_values = potential(thetas)

        # Check specific points: 0, 2pi, -2pi should be zero (ground states)
        critical_points = [0, 2*np.pi, -2*np.pi]
        epsilon = 1e-10

        for theta in critical_points:
            val = potential(theta)
            self.assertLess(val, epsilon, f"Potential at {theta} should be ~0 (Vacuum state)")
            print(f"Checked Vacuum State at theta={theta:.2f}: V={val}")

        # Check a non-integer multiple of 2pi (e.g., pi)
        val_pi = potential(np.pi)
        self.assertAlmostEqual(val_pi, 2.0 * self.lambda_val, places=5,
                             msg="Potential at pi should be maximal (2*lambda)")
        print(f"Checked Excited State at theta=pi: V={val_pi}")

    def test_lemma_a1_variation(self):
        """
        Symbolic verification of Lemma A.1.
        Verifies the functional derivative of the cosine potential leads to the sine term.
        """
        print("\n--- Testing Lemma A.1 (Symbolic) ---")

        theta = sp.symbols('theta')
        lambda_sym = sp.symbols('lambda')

        # V = lambda * (1 - cos(theta))
        # Note: In the paper, theta is Delta_theta.
        V = lambda_sym * (1 - sp.cos(theta))

        # Derivative w.r.t theta
        dV_dtheta = sp.diff(V, theta)

        print(f"V = {V}")
        print(f"dV/dtheta = {dV_dtheta}")

        expected = lambda_sym * sp.sin(theta)
        self.assertEqual(dV_dtheta, expected, "Lemma A.1 failed: Derivative of potential is not lambda*sin(theta)")
        print("Lemma A.1 Verified: Restoring force is sinusoidal.")

    def test_metric_perturbation_symmetry_eq11(self):
        """
        Numerical verification of Equation 11: Metric Perturbation Tensor Xi_mu_nu.
        Ensures the construction yields a symmetric tensor, which is required for it
        to be added to the metric g_mu_nu.
        """
        print("\n--- Testing Metric Perturbation Symmetry (Eq 11) ---")

        # Mock 4-vectors
        # Gradient of psi (complex) -> split into real/imag for simulation,
        # but Eq 11 uses d(psi*)d(psi).
        # Let's assume psi = A * e^(i*theta), so d_mu psi is complex.

        # Random complex gradients for d_mu_psi
        d_psi = np.random.rand(4) + 1j * np.random.rand(4)
        d_psi_star = np.conjugate(d_psi)

        # Random real intention vector I_mu
        I = np.random.rand(4)

        gamma = 0.1
        sigma_I = 1.5

        # Construct Xi_mu_nu
        # Eq 11: Xi_uv = d_(u psi* d_v) psi + (gamma/sigma^2) * I_u * I_v
        # Note: The paper writes d_(u psi* d_v) psi.
        # Standard notation d_(u...v) usually implies symmetrization,
        # but d_u psi* * d_v psi is already Hermitian symmetric if we look at the whole form?
        # Actually, d_u psi* d_v psi is NOT symmetric in u,v unless d_u psi is proportional to d_v psi.
        # However, the paper notation likely implies symmetrization or the term itself is:
        # Eq 11 text: "d_(u psi* d_v) psi"
        # The parentheses () around indices usually denote symmetrization: T_(ab) = 1/2(T_ab + T_ba).

        Xi = np.zeros((4,4), dtype=complex)

        term2_prefactor = gamma / (sigma_I**2)

        for mu in range(4):
            for nu in range(4):
                # Calculate the raw term d_mu psi* * d_nu psi
                raw_term = d_psi_star[mu] * d_psi[nu]

                # Apply symmetrization logic implied by d_(u ... v)
                # If the paper means partial_(mu psi*) * partial_nu(psi), this isn't symmetric.
                # If the paper implies symmetrization of the indices:
                # Term 1 = 0.5 * (d_mu psi* d_nu psi + d_nu psi* d_mu psi)

                # Let's calculate the term assuming the symmetrization brackets in Eq 11 apply to the indices
                term1 = 0.5 * (d_psi_star[mu] * d_psi[nu] + d_psi_star[nu] * d_psi[mu])

                term2 = term2_prefactor * I[mu] * I[nu]

                Xi[mu, nu] = term1 + term2

        # Check symmetry: Xi_mu_nu == Xi_nu_mu
        is_symmetric = np.allclose(Xi, Xi.T)
        self.assertTrue(is_symmetric, "Metric Perturbation Xi_mu_nu is not symmetric!")
        print(f"Metric Perturbation Symmetry Verified: {is_symmetric}")

        # Additional Check: Real-valuedness
        # The metric must be real. The term d_mu psi* d_nu psi is not generally real.
        # However, the symmetrized version (d* d + d* d) might still be complex?
        # (a-ib)(c+id) + (c-id)(a+ib) = (ac + bd + i(ad-bc)) + (ca + db + i(cb-da))
        # = 2(ac+bd). The imaginary parts cancel!
        # Let's check if our calculated Xi is real.
        max_imag = np.max(np.abs(Xi.imag))
        self.assertLess(max_imag, 1e-10, "Metric Perturbation must be real-valued")
        print("Metric Perturbation Real-Valuedness Verified")

if __name__ == '__main__':
    unittest.main(argv=['first-arg-is-ignored'], exit=False)